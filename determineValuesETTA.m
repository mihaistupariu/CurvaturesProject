function [ ss, curburakwb, curburahwb, curburanormmax, curburanormmin, curburaktaubin, curburahtaubin, matErr] = ...
    determineValuesETTA(weighted_normal, tri_areas, coord1_vf, coord2_vf, coord3_vf, index_vf, neighbors_mat )
%% Description
% The function processes the 1-ring neigborhood generated by the vectors
% provides curvature values for Euler's Theorem and Tensor Approach methods
% Input.
%   weighted normal: vector of weighted normals, needed in computations
%	coord1_vf, coord2_vf, coord3_vf (current vertex is origin) the coord1_vf: column of x-coordinates; same for 2 (y); 3(z)
%   index_vf: ID of the current vertex
% Output.
%   ss: sum of angles (radians)
%   curburakwb, curburahwb: Gaussian and mean curvature (ET)
%   curburaktaubin, curburahtaubin: Gaussian and mean curvature (TA)

%% Initializations
[nvec, ~] = size(coord1_vf);
ss=0;
curburakwb=0;
curburahwb=0;
ponderi=zeros(nvec,1); % the weights (to be used in Taubin's method)
suma_ponderi=0; % the sum of the weights (need to normalize)
 
 
%% First loop, mainly for ET (one info for TA)
 for jj=1:nvec % take all the vertices that are adjacent to index_vf
     if (jj==nvec) 
         jj1=1; %compute the "next" for the last vertex
     else jj1=jj+1; 
     end
     % select the vectors vv1, vv2
     v1=[coord1_vf(jj,1), coord2_vf(jj,1),coord3_vf(jj,1)];
     v2=[coord1_vf(jj1,1), coord2_vf(jj1,1),coord3_vf(jj1,1)];
     % compute the angle between these vectors 
     cosinus = dot(v1, v2); norm1=norm(v1); cosinus = cosinus/norm1; norm2=norm(v2);cosinus=cosinus/norm2;
     unghi=acos(cosinus);
     ss=ss+unghi;
     % compute the "normal" curvature in the direction vv1 ("predecesor")
     if (jj==1)
        curbura_pred=2*dot(weighted_normal(index_vf,:), v1); curbura_pred=curbura_pred/(norm1^2);
     else
        curbura_pred=curbura_succ;
     end
     % compute the "normal" curvature in the direction vv2 ("succesor")
     curbura_succ=2*dot(weighted_normal(index_vf,:), v2); curbura_succ=curbura_succ/(norm2^2);
     %%%%%%%%%%%%%%%%%%%%%
     % add relevant terms to the sum providing the curvature in W&B
     curburahwb=curburahwb+unghi*(curbura_pred+curbura_succ);   
     curburakwb=curburakwb+unghi*(curbura_pred.^2+curbura_succ.^2);
     %%%%%%%%%%%%%%%%%%%%%
     % if necessary, modify the max/min of the 'normal directional curvatures'
     if (jj==1)
        curburanormmax=curbura_succ; curburanormmin=curbura_succ;
     else 
         if (curbura_succ > curburanormmax)
            curburanormmax=curbura_succ;
         end
         if (curbura_succ < curburanormmin)
            curburanormmin=curbura_succ;
         end
     end
     %%%%%%%%%%%%%%%%%%%%
     % compute the weight corresponding to the edge determined by the
     % neighbor jj (used in Taubin's method)
     if (jj==1)
          jj2=nvec;
     else 
          jj2=jj-1;
     end
     trg1=neighbors_mat(1,jj); trg2=neighbors_mat(1,jj2);
     ponderi(jj,1)= tri_areas(trg1)+tri_areas(trg2);
     suma_ponderi=suma_ponderi+ponderi(jj,1);
 end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Euler's Theorem: normalise
curburahwb=curburahwb/(4*pi); 
curburakwb=3*curburahwb.^2-curburakwb/(2*pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tensor Approach
% need these matrices for each neigbour
SymNorm=transpose(weighted_normal(index_vf,:))*weighted_normal(index_vf, :); % 3x3 sym matrix associated to the normal
Id_SymNorm=eye(3)-SymNorm; % identity Minus SymNorm
MatrM=zeros(3,3);


%% Second loop: TA
% TA: take again all vertices and compute the 3x3 matrix MatrM
for jj=1:nvec
    CoordVect=[coord1_vf(jj,1); coord2_vf(jj,1); coord3_vf(jj,1)]; % the position vector of jj
    ponderi(jj,1)=ponderi(jj,1)/suma_ponderi; % compute the weight for neighbor jj
    Tens=Id_SymNorm * CoordVect; % multiply by the position vector of jj
    Tens=Tens/norm(Tens); % normalize
    CurvTens= dot (weighted_normal(index_vf,:), CoordVect); CurvTens=2*CurvTens; CurvTens=CurvTens/(norm(CoordVect).^2);% compute the 'normal' curvature in direction Tens
    MatrM=MatrM + ponderi(jj,1)*CurvTens*Tens *transpose(Tens); % compute the matrix M_v
end
% MatrM (M_v) has eigevalue 0 and two others, that will provide the principal curvatures
[kappa, matErr]= extractEigenv (weighted_normal, index_vf, MatrM); 

curbura1taubin=3*kappa(1,1)-kappa(2,1);
curbura2taubin=3*kappa(2,1)-kappa(1,1);
curburaktaubin=curbura1taubin*curbura2taubin;
curburahtaubin=(curbura1taubin+curbura2taubin)/2; 
 

end

 %% FUNCTIONS USED 
 
    function [eigenv, matriceErori] = extractEigenv (wgh_n,ind_v,matr)
      % this function extracts the non-zero eigenvalues from a column
      % vector of eigenvalues (one of the entries is assumed to be 0)
      matriceErori=zeros(1,3);
      eigenv=zeros(2,1);
      eigmatr=eig(matr);
      % check for errors
      % one of the eigenvalues must be zero
      Modulmatr(:,1)=abs (eig(matr));
      if (min (Modulmatr(:,1)))> eps ('double')
        %disp ('ERROR1');
        matriceErori(1,1)=1;
      end
      % the weigthed normal must be an eigenvector
      if (norm(matr*transpose(wgh_n(ind_v, :)))>eps('double') )
           % disp('ERROR2');
            matriceErori(1,2)=1;
      end
      minAbsEig=find (Modulmatr==min(abs(eig(matr))) );  
      indiceMinAbsEig=minAbsEig(1,1);
      indCrtRun=0;
      for indCrt=1:3
          if (indCrt~=indiceMinAbsEig)
              indCrtRun=indCrtRun+1;
              eigenv(indCrtRun,1)=eigmatr(indCrt,1);
          end
      end
 
    end

 

